from cassandra.cluster import Cluster, Session
from cassandra.auth import PlainTextAuthProvider
from cassandra.cqlengine import columns
from cassandra.cqlengine.models import Model
import json
import pandas as pd
from pprint import pprint

CREDENTIALS_PATH = "credentials/"
DATASET_PATH = "dataset/"


def connectToDB():
    # This secure connect bundle is autogenerated when you download your SCB,
    # if yours is different update the file name below
    cloud_config = {
        "secure_connect_bundle": CREDENTIALS_PATH
        + "secure-connect-big-data-project-db.zip"
    }

    # This token JSON file is autogenerated when you download your token,
    # if yours is different update the file name below
    with open(CREDENTIALS_PATH + "big_data_project_db-token.json") as f:
        secrets = json.load(f)

    CLIENT_ID = secrets["clientId"]
    CLIENT_SECRET = secrets["secret"]

    auth_provider = PlainTextAuthProvider(CLIENT_ID, CLIENT_SECRET)
    cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)
    session = cluster.connect()

    row = session.execute("select release_version from system.local").one()
    if row:
        print("Connection successful!")
        return session
    else:
        print("An error occurred.")
        return -1


def createTables(session: Session):

    create_popular_recipes = """
        CREATE TABLE IF NOT EXISTS recipes.popular_recipes(
            submitted date,
            avg_rating float,
            name text,
            id int,
            PRIMARY KEY (submitted, avg_rating)
        ) WITH CLUSTERING ORDER BY (avg_rating DESC);
    """
    create_recipes_by_keyword = """
        CREATE TABLE IF NOT EXISTS recipes.recipes_keyword(
            keyword text,
            avg_rating float,
            name text,
            id int,
            PRIMARY KEY (keyword, avg_rating)
        ) WITH CLUSTERING ORDER BY (avg_rating DESC);
    """

    create_recipes_by_difficulty = """
        CREATE TABLE IF NOT EXISTS recipes.recipes_difficulty(
            difficulty smallint,
            avg_rating float,
            name text,
            id int,
            PRIMARY KEY (difficulty, avg_rating)
        ) WITH CLUSTERING ORDER BY (avg_rating DESC);
    """

    create_recipes_by_tag_submitted = """
        CREATE TABLE IF NOT EXISTS recipes.recipes_tag_submitted(
            tag text,
            submitted date,
            avg_rating float,
            name text,
            id int,
            PRIMARY KEY (tag, submitted, avg_rating)
        ) WITH CLUSTERING ORDER BY (submitted DESC, avg_rating DESC);
    """

    create_recipes_by_tag_rating = """
        CREATE TABLE IF NOT EXISTS recipes.recipes_tag_rating(
            submitted date,
            avg_rating float,
            name text,
            id int,
            PRIMARY KEY (submitted, avg_rating)
        ) WITH CLUSTERING ORDER BY (avg_rating DESC);
    """
    create_recipes_details = """
        CREATE TABLE IF NOT EXISTS recipes.recipes_details(
            id int,
            name text,
            minutes int,
            contributor_id int,
            submitted date,
            tags list<text>,
            nutrition list<float>,
            n_steps smallint,
            steps list<text>,
            description text,
            ingredients list<text>,
            n_ingredients smallint,
            avg_rating float,
            PRIMARY KEY (id)
        );
    """

    session.execute(create_popular_recipes)
    session.execute(create_recipes_by_keyword)
    session.execute(create_recipes_by_difficulty)
    session.execute(create_recipes_by_tag_submitted)
    session.execute(create_recipes_by_tag_rating)
    session.execute(create_recipes_details)


def loadData(session: Session):
    # Load recipes data
    recipes_df = pd.read_csv(DATASET_PATH + "RAW_recipes.csv")
    # Load interactions data
    interactions_df = pd.read_csv(DATASET_PATH + "RAW_interactions.csv")

    # Merge recipes and interactions dataframes on recipe id, averaging out each recipe's ratings
    merged_df = pd.merge(
        recipes_df,
        interactions_df.groupby("recipe_id")["rating"]
        .mean()
        .reset_index()
        .rename(columns={"rating": "avg_rating"}),
        how="left",
        left_on="id",
        right_on="recipe_id",
    )

    # Prepare the insert statement for recipes_details table
    insert_query = session.prepare(
        """
        INSERT INTO recipes.recipes_details (id, name, minutes, contributor_id, submitted, tags, nutrition, n_steps, steps, description, ingredients, n_ingredients, avg_rating)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
    """
    )

    # Iterate over each row in the merged DataFrame and insert data into the table
    for idx, row in merged_df[:5].iterrows():
        # Convert string representations of lists to actual lists and remove extra quotes
        tags = [tag.strip("'''") for tag in row["tags"][1:-1].split(", ")]
        nutrition = [float(n) for n in row["nutrition"][1:-1].split(", ")]

        # Assuming steps are stored as a string list with extra triple quotes
        steps = [step.strip("'''") for step in row["steps"][1:-1].split(", ")]
        ingredients = [
            ingredient.strip("'''")
            for ingredient in row["ingredients"][1:-1].split(", ")
        ]
        # Execute the insert statement for each row
        session.execute(
            insert_query,
            (
                row["id"],
                row["name"],
                row["minutes"],
                row["contributor_id"],
                row["submitted"],
                tags,
                nutrition,
                row["n_steps"],
                steps,
                row["description"],
                ingredients,
                row["n_ingredients"],
                row.get(
                    "avg_rating", None
                ),  # Use .get() to handle missing avg_rating values
            ),
        )


def stringFromDataframe(df: pd.DataFrame) -> str:
    # Extract values from merged dataframe into a list
    values_list = df.values.tolist()

    # Flatten the two-dimensional list into a one-dimensional list
    flattened_list = [item for sublist in values_list for item in sublist]

    # Convert the flattened list to a single string separated by commas
    return ",".join(map(str, flattened_list))
